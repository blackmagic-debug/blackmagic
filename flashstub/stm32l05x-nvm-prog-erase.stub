// 
// stm32l05x-nvm-prog-erase.o:     file format elf32-littlearm
// 
// 
// Disassembly of section .text:
// 
// 00000000 <stm32l05x_nvm_prog_erase>:
//                   ".align 2\n\t"
//                   ".word 0\n\t"
//                   ".word 0\n\t"
//                   ".word 0\n\t"
//                   ".word 0\n\t"
//                   "0:");
  [0x0/2] = 0xe008, //    0:	e008      	b.n	14 <stm32l05x_nvm_prog_erase+0x14>
  [0x2/2] = 0x46c0, //    2:	46c0      	nop			; (mov r8, r8)
// 	...
// 
//   // Align to the start of the first page so that we make sure to erase
//   // all of the target pages.
//   auto remainder    = reinterpret_cast<uint32_t> (Info.destination)
//     & (Info.page_size - 1);
  [0x14/2] = 0x4a1a, //   14:	4a1a      	ldr	r2, [pc, #104]	; (80 <stm32l05x_nvm_prog_erase+0x80>)
  [0x16/2] = 0x68d3, //   16:	68d3      	ldr	r3, [r2, #12]
  [0x18/2] = 0x6811, //   18:	6811      	ldr	r1, [r2, #0]
//   Info.size        += remainder;
  [0x1a/2] = 0x6850, //   1a:	6850      	ldr	r0, [r2, #4]
//                   "0:");
// 
//   // Align to the start of the first page so that we make sure to erase
//   // all of the target pages.
//   auto remainder    = reinterpret_cast<uint32_t> (Info.destination)
//     & (Info.page_size - 1);
  [0x1c/2] = 0x3b01, //   1c:	3b01      	subs	r3, #1
  [0x1e/2] = 0x400b, //   1e:	400b      	ands	r3, r1
//   Info.size        += remainder;
  [0x20/2] = 0x1818, //   20:	1818      	adds	r0, r3, r0
//   Info.destination -= remainder/sizeof (*Info.destination);
  [0x22/2] = 0x089b, //   22:	089b      	lsrs	r3, r3, #2
  [0x24/2] = 0x009b, //   24:	009b      	lsls	r3, r3, #2
  [0x26/2] = 0x1acb, //   26:	1acb      	subs	r3, r1, r3
// #define Info (*reinterpret_cast<stm32lx_nvm_stub_info*>(STM32Lx_STUB_INFO_PHYS))
// 
// 
// namespace {
//   inline __attribute((always_inline)) bool unlock () {
//     Nvm.pecr      = STM32Lx_NVM_PECR_PELOCK; // Lock to guarantee unlock
  [0x28/2] = 0x2101, //   28:	2101      	movs	r1, #1
  [0x2a/2] = 0x6013, //   2a:	6013      	str	r3, [r2, #0]
  [0x2c/2] = 0x4b15, //   2c:	4b15      	ldr	r3, [pc, #84]	; (84 <stm32l05x_nvm_prog_erase+0x84>)
// 
//   // Align to the start of the first page so that we make sure to erase
//   // all of the target pages.
//   auto remainder    = reinterpret_cast<uint32_t> (Info.destination)
//     & (Info.page_size - 1);
//   Info.size        += remainder;
  [0x2e/2] = 0x6050, //   2e:	6050      	str	r0, [r2, #4]
  [0x30/2] = 0x6059, //   30:	6059      	str	r1, [r3, #4]
//     Nvm.pkeyr     = STM32::NVM::PKEY1;
  [0x32/2] = 0x4915, //   32:	4915      	ldr	r1, [pc, #84]	; (88 <stm32l05x_nvm_prog_erase+0x88>)
  [0x34/2] = 0x60d9, //   34:	60d9      	str	r1, [r3, #12]
//     Nvm.pkeyr     = STM32::NVM::PKEY2;
  [0x36/2] = 0x4915, //   36:	4915      	ldr	r1, [pc, #84]	; (8c <stm32l05x_nvm_prog_erase+0x8c>)
  [0x38/2] = 0x60d9, //   38:	60d9      	str	r1, [r3, #12]
//     Nvm.prgkeyr   = STM32::NVM::PRGKEY1;
  [0x3a/2] = 0x4915, //   3a:	4915      	ldr	r1, [pc, #84]	; (90 <stm32l05x_nvm_prog_erase+0x90>)
  [0x3c/2] = 0x6119, //   3c:	6119      	str	r1, [r3, #16]
//     Nvm.prgkeyr   = STM32::NVM::PRGKEY2;
  [0x3e/2] = 0x4915, //   3e:	4915      	ldr	r1, [pc, #84]	; (94 <stm32l05x_nvm_prog_erase+0x94>)
  [0x40/2] = 0x6119, //   40:	6119      	str	r1, [r3, #16]
//     return !(Nvm.pecr & STM32Lx_NVM_PECR_PRGLOCK);
  [0x42/2] = 0x6858, //   42:	6858      	ldr	r0, [r3, #4]
  [0x44/2] = 0x1c11, //   44:	1c11      	adds	r1, r2, #0
//   Info.destination -= remainder/sizeof (*Info.destination);
// 
//   if (!unlock ())
  [0x46/2] = 0x0782, //   46:	0782      	lsls	r2, r0, #30
  [0x48/2] = 0xd502, //   48:	d502      	bpl.n	50 <stm32l05x_nvm_prog_erase+0x50>
//   }
//   inline __attribute((always_inline)) void lock () {
//     Nvm.pecr      = STM32Lx_NVM_PECR_PELOCK; }
  [0x4a/2] = 0x2201, //   4a:	2201      	movs	r2, #1
  [0x4c/2] = 0x605a, //   4c:	605a      	str	r2, [r3, #4]
//     Info.size -= Info.page_size;
//   }
// 
// quit:
//   lock ();
//   __asm volatile ("bkpt");
  [0x4e/2] = 0xbe00, //   4e:	be00      	bkpt	0x0000
// 
//   if (!unlock ())
//     goto quit;
// 
//   // Enable erasing
//   Nvm.pecr = STM32Lx_NVM_PECR_PROG | STM32Lx_NVM_PECR_ERASE;
  [0x50/2] = 0x2282, //   50:	2282      	movs	r2, #130	; 0x82
  [0x52/2] = 0x0092, //   52:	0092      	lsls	r2, r2, #2
  [0x54/2] = 0x605a, //   54:	605a      	str	r2, [r3, #4]
//   if ((Nvm.pecr & (STM32Lx_NVM_PECR_PROG | STM32Lx_NVM_PECR_ERASE))
  [0x56/2] = 0x6858, //   56:	6858      	ldr	r0, [r3, #4]
  [0x58/2] = 0x4010, //   58:	4010      	ands	r0, r2
  [0x5a/2] = 0x4290, //   5a:	4290      	cmp	r0, r2
  [0x5c/2] = 0xd1f5, //   5c:	d1f5      	bne.n	4a <stm32l05x_nvm_prog_erase+0x4a>
//       != (STM32Lx_NVM_PECR_PROG | STM32Lx_NVM_PECR_ERASE))
//     goto quit;
// 
//   while (Info.size > 0) {
  [0x5e/2] = 0x6848, //   5e:	6848      	ldr	r0, [r1, #4]
  [0x60/2] = 0x4a07, //   60:	4a07      	ldr	r2, [pc, #28]	; (80 <stm32l05x_nvm_prog_erase+0x80>)
  [0x62/2] = 0x2800, //   62:	2800      	cmp	r0, #0
  [0x64/2] = 0xddf1, //   64:	ddf1      	ble.n	4a <stm32l05x_nvm_prog_erase+0x4a>
//     *Info.destination = 0;      // Initiate erase
  [0x66/2] = 0x2400, //   66:	2400      	movs	r4, #0
  [0x68/2] = 0x6810, //   68:	6810      	ldr	r0, [r2, #0]
// 
//     Info.destination += Info.page_size/sizeof (*Info.destination);
  [0x6a/2] = 0x6815, //   6a:	6815      	ldr	r5, [r2, #0]
//   if ((Nvm.pecr & (STM32Lx_NVM_PECR_PROG | STM32Lx_NVM_PECR_ERASE))
//       != (STM32Lx_NVM_PECR_PROG | STM32Lx_NVM_PECR_ERASE))
//     goto quit;
// 
//   while (Info.size > 0) {
//     *Info.destination = 0;      // Initiate erase
  [0x6c/2] = 0x6004, //   6c:	6004      	str	r4, [r0, #0]
// 
//     Info.destination += Info.page_size/sizeof (*Info.destination);
  [0x6e/2] = 0x68d4, //   6e:	68d4      	ldr	r4, [r2, #12]
  [0x70/2] = 0x08a0, //   70:	08a0      	lsrs	r0, r4, #2
  [0x72/2] = 0x0080, //   72:	0080      	lsls	r0, r0, #2
  [0x74/2] = 0x1828, //   74:	1828      	adds	r0, r5, r0
  [0x76/2] = 0x6010, //   76:	6010      	str	r0, [r2, #0]
//     Info.size -= Info.page_size;
  [0x78/2] = 0x6850, //   78:	6850      	ldr	r0, [r2, #4]
  [0x7a/2] = 0x1b00, //   7a:	1b00      	subs	r0, r0, r4
  [0x7c/2] = 0x6050, //   7c:	6050      	str	r0, [r2, #4]
  [0x7e/2] = 0xe7ee, //   7e:	e7ee      	b.n	5e <stm32l05x_nvm_prog_erase+0x5e>
  [0x80/2] = 0x0004, //   80:	20000004 	.word	0x20000004
  [0x80/2 + 1] = 0x2000,
  [0x84/2] = 0x2000, //   84:	40022000 	.word	0x40022000
  [0x84/2 + 1] = 0x4002,
  [0x88/2] = 0xcdef, //   88:	89abcdef 	.word	0x89abcdef
  [0x88/2 + 1] = 0x89ab,
  [0x8c/2] = 0x0405, //   8c:	02030405 	.word	0x02030405
  [0x8c/2 + 1] = 0x0203,
  [0x90/2] = 0xaebf, //   90:	8c9daebf 	.word	0x8c9daebf
  [0x90/2 + 1] = 0x8c9d,
  [0x94/2] = 0x1516, //   94:	13141516 	.word	0x13141516
  [0x94/2 + 1] = 0x1314,
