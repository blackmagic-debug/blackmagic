This is driver support for a STM32C103C8 'Bluepill' development  board which are sold 
very very cheaply out of China.  It supports JTAG, SWD and SWO/SWV. It is nothing like 
as capable as a full bmp, but it will get you going for cheap.

The typical product that this driver applies to is shown at;

http://wiki.stm32duino.com/index.php?title=Blue_Pill

(Note the comment about R10 having the wrong value....that's important if you want to use USB).

Both the jumpers on the board should be set North (i.e. nearest the USB connector) to give
logic 0 input and allow regular boot.  BOOT1 (the jumper nearest the reset button) can
be set south (logic1) for force dfu mode....this is useful if you've flashed a bad application.
Note that if no jumpers are fitted the behaviour is not determined and is likely to be unreliable.

Pinouts etc have been set to make life easy for creating a breakout lead.

 *
 * LED0 = 	     PC13	(Yellow LED : Running)
 *
 * SRST_OUT = 	     PB5
 * TDI = 	     PB6
 * TMS = 	     PB9  (==SWDIO)
 * TCK = 	     PB8  (==SWCLK)
 * TDO = 	     PB7  (==SDO)
 * nSRST = 	     PB5 
 * VSense =          PB4
 * TRST =            PB3

... and on the other side;

 * Serial port;
 * PA2
 * PA3

You can change these pins in the platform.h file if you need to, but TDO _must_ stay on UART1_RX
if you want to use high speed SWO/SWV (above 2.250Mbps).
 
Build the firmware by following the standard instructions but with PROBE_HOST=bluepill, like this;

CROSS_COMPILE=~/bin/armgcc/bin/arm-none-eabi- make PROBE_HOST=bluepill

...this will give you the needed output files in the src directory. Now, you will need
some sort of debug probe (like an existing BM probe) to load the initial bootloader.
Assuming you've got one then Initial programming of the bootloader can be done via GDB. 
The 4-pin header on the end of the board is used for this job, using the pinout marked in it.

The whole sequence goes something like this;

$ ~/bin/armgcc/bin/arm-none-eabi-gdb
GNU gdb (GNU Tools for ARM Embedded Processors) 7.10.1.20160923-cvs
Copyright (C) 2015 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "--host=x86_64-apple-darwin10 --target=arm-none-eabi".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
<http://www.gnu.org/software/gdb/documentation/>.
For help, type "help".
Type "apropos word" to search for commands related to "word".
(gdb) target extended-remote /dev/cu.usbmodemXXXXXXXX
Remote debugging using /dev/cu.usbmodemXXXXXXXX
(gdb) monitor swdp_scan
Target voltage: unknown
Available Targets:
No. Att Driver
 1      STM32F1 medium density
(gdb) attach 1
Attaching to Remote target
0xfffffffe in ?? ()
(gdb) load blackmagic_dfu
Loading section .text, size 0x1938 lma 0x8000000
Loading section .data, size 0x34 lma 0x8001938
Start address 0x8001650, load size 6508
Transfer rate: 12 KB/sec, 813 bytes/write.
(gdb) q
A debugging session is active.

  Inferior 1 [Remote target] will be detached.

Quit anyway? (y or n) y
Detaching from program: , Remote target
$ dfu-util -d 1d50:6018,:6017 -s 0x08002000:leave -D blackmagic.bin
dfu-util 0.9

Copyright 2005-2009 Weston Schmidt, Harald Welte and OpenMoko Inc.
Copyright 2010-2016 Tormod Volden and Stefan Schmidt
This program is Free Software and has ABSOLUTELY NO WARRANTY
Please report bugs to http://sourceforge.net/p/dfu-util/tickets/

dfu-util: Invalid DFU suffix signature
dfu-util: A valid DFU suffix will be required in a future dfu-util release!!!
Deducing device DFU version from functional descriptor length
Opening DFU capable USB device...
ID 1d50:6017
Run-time device DFU version 011a
Claiming USB DFU Interface...
Setting Alternate Setting #0 ...
Determining device status: state = dfuIDLE, status = 0
dfuIDLE, continuing
DFU mode device DFU version 011a
Device returned transfer size 1024
DfuSe interface name: "Internal Flash   "
Downloading to address = 0x08002000, size = 57036
Download    [=========================] 100%        57036 bytes
Download done.
File downloaded successfully
Transitioning to dfuMANIFEST state
$ dfu-util -l
dfu-util 0.9

Copyright 2005-2009 Weston Schmidt, Harald Welte and OpenMoko Inc.
Copyright 2010-2016 Tormod Volden and Stefan Schmidt
This program is Free Software and has ABSOLUTELY NO WARRANTY
Please report bugs to http://sourceforge.net/p/dfu-util/tickets/

Deducing device DFU version from functional descriptor length
Found Runtime: [1d50:6018] ver=0100, devnum=13, cfg=1, intf=4, path="20-4", alt=0, name="Black Magic Firmware Upgrade (Bluepill)", serial="XXXXXXXX"

...and that's it, you've got a working BM Debugger. See the Connectors file for pinout info.

To use SWO
==========

The SWO data rate that comes out of the chip _must_ match the rate that the debugger expects.
By default the baudrate is 1.8MBps but that can be changed as an optional parameter to the 
monitor traceswo command, like this;

monitor traceswo 115200

....would set the swo output at the low speed of 115kbps.  

The STM32F103 cannot go faster than 4.5Mbps, but the USB starts losing
data much above 1.8Mbps if you're streaming continuously, so we set 
it to 1.8Mbps....you can safely go higher if your data is bursty.

Depending on what you're using to wake up SWO on the target side, you 
may need code to get it into the correct mode and emitting data.  
An example for a STM32F103....

    /* STM32 specific configuration to enable the TRACESWO IO pin */
    RCC->APB2ENR |= RCC_APB2ENR_AFIOEN;
    AFIO->MAPR |= (2 << 24); // Disable JTAG to release TRACESWO
    DBGMCU->CR |= DBGMCU_CR_TRACE_IOEN; // Enable IO trace pins

    *((volatile unsigned *)(0xE0040010)) = 39;  // Output bits at 72000000/(39+1)=1.8MHz.
    *((volatile unsigned *)(0xE00400F0)) = 2;  // Use Async mode
    *((volatile unsigned *)(0xE0040304)) = 0; // Disable formatter

    /* Configure instrumentation trace macroblock */
    ITM->LAR = 0xC5ACCE55;
    ITM->TCR = 0x00010005;
    ITM->TER = 0xFFFFFFFF; // Enable all stimulus ports

The SWO data appears on USB Interface 5, Endpoint 5.

A program swolisten.c is included which will listen to this endpoint, decode the datastream, and output it
to a set of unix fifos which can then be used as the input to other programs (e.g. cat, or something more
sophisticated). 

The command line to build the tool is;

gcc -I /usr/local/include/libusb-1.0 -L /usr/local/lib  -lusb-1.0 swolisten.c -O swolisten

...you will obviously need to change the paths to your libusb files.  By default the tool will create
fifos for the first 32 channels in a directory swo (which you will need to create) as follows;

>ls swo/
channel0  channel4  channel8	channelC       channelG	  channelK channelO	   channelS
channel1  channel5  channel9	channelD       channelH	  channelL channelP	   channelT
channel2  channel6  channelA	channelE       channelI	  channelM channelQ	   channelU
channel3  channel7  channelB	channelF       channelJ	  channelN channelR	   channelV
>cat swo/channel0
<<OUTPUT FROM ITM Channel 0>>

